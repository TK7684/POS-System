/**
 * Report Generation Module
 * Generates comprehensive test reports in HTML, JSON, and CSV formats
 * Requirements: 1.5, 2.10, 3.10, 4.10, 5.10, 6.10, 7.10, 8.10, 9.10, 10.10
 */

class ReportGenerationModule {
  constructor(config = {}) {
    this.config = {
      outputDir: config.outputDir || './test-reports',
      includeScreenshots: config.includeScreenshots || false,
      historyLimit: config.historyLimit || 10,
      ...config
    };
    this.reportHistory = [];
  }

  /**
   * Generate HTML report with summary cards and detailed sections
   * Requirements: 1.5, 2.10, 3.10, 4.10, 5.10, 6.10, 7.10, 8.10, 9.10, 10.10
   */
  generateHTMLReport(testResults) {
    const timestamp = new Date().toISOString();
    const summary = this._calculateSummary(testResults);
    
    const html = `
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Comprehensive Test Report - ${new Date(timestamp).toLocaleString()}</title>
  <style>
    ${this._getReportStyles()}
  </style>
</head>
<body>
  <div class="report-container">
    <header class="report-header">
      <h1>Comprehensive Test Report</h1>
      <div class="report-meta">
        <span class="meta-item"><strong>Generated:</strong> ${new Date(timestamp).toLocaleString()}</span>
        <span class="meta-item"><strong>Duration:</strong> ${this._formatDuration(testResults.metadata?.duration || 0)}</span>
        <span class="meta-item"><strong>Environment:</strong> ${testResults.metadata?.environment || 'Unknown'}</span>
        <span class="meta-item"><strong>Version:</strong> ${testResults.metadata?.version || 'N/A'}</span>
      </div>
    </header>

    ${this._generateSummaryCards(summary)}
    
    ${this._generateDetailedSections(testResults)}
    
    ${this._generateRequirementTraceability(testResults)}

    <footer class="report-footer">
      <p>Generated by Comprehensive Test Suite | ${timestamp}</p>
    </footer>
  </div>

  <script>
    ${this._getReportScripts()}
  </script>
</body>
</html>
`.trim();

    return html;
  }

  /**
   * Generate summary cards for visual status indicators
   * Requirements: 1.5, 2.10, 3.10, 4.10, 5.10, 6.10, 7.10, 8.10, 9.10, 10.10
   */
  _generateSummaryCards(summary) {
    const successRate = summary.totalTests > 0 
      ? ((summary.passed / summary.totalTests) * 100).toFixed(1)
      : 0;
    
    const statusClass = successRate >= 95 ? 'success' 
      : successRate >= 80 ? 'warning' 
      : 'error';

    return `
  <section class="summary-section">
    <h2>Test Summary</h2>
    <div class="summary-cards">
      <div class="summary-card ${statusClass}">
        <div class="card-icon">âœ“</div>
        <div class="card-content">
          <div class="card-value">${successRate}%</div>
          <div class="card-label">Success Rate</div>
        </div>
      </div>
      
      <div class="summary-card">
        <div class="card-icon">ðŸ“Š</div>
        <div class="card-content">
          <div class="card-value">${summary.totalTests}</div>
          <div class="card-label">Total Tests</div>
        </div>
      </div>
      
      <div class="summary-card success">
        <div class="card-icon">âœ“</div>
        <div class="card-content">
          <div class="card-value">${summary.passed}</div>
          <div class="card-label">Passed</div>
        </div>
      </div>
      
      <div class="summary-card error">
        <div class="card-icon">âœ—</div>
        <div class="card-content">
          <div class="card-value">${summary.failed}</div>
          <div class="card-label">Failed</div>
        </div>
      </div>
      
      <div class="summary-card warning">
        <div class="card-icon">âš </div>
        <div class="card-content">
          <div class="card-value">${summary.warnings}</div>
          <div class="card-label">Warnings</div>
        </div>
      </div>
      
      <div class="summary-card">
        <div class="card-icon">âŠ˜</div>
        <div class="card-content">
          <div class="card-value">${summary.skipped}</div>
          <div class="card-label">Skipped</div>
        </div>
      </div>
    </div>
  </section>
`;
  }

  /**
   * Generate detailed sections for recommendations and issues
   * Requirements: 1.5, 2.10, 3.10, 4.10, 5.10, 6.10, 7.10, 8.10, 9.10, 10.10
   */
  _generateDetailedSections(testResults) {
    const categories = testResults.categories || [];
    let sectionsHTML = '<section class="detailed-section"><h2>Test Categories</h2>';
    
    categories.forEach(category => {
      const statusIcon = this._getStatusIcon(category.status);
      const statusClass = category.status || 'unknown';
      
      sectionsHTML += `
      <div class="category-section">
        <div class="category-header" onclick="toggleCategory('${this._sanitizeId(category.name)}')">
          <span class="status-icon ${statusClass}">${statusIcon}</span>
          <h3>${category.name}</h3>
          <span class="category-stats">
            ${category.tests?.length || 0} tests | ${category.issues?.length || 0} issues
          </span>
          <span class="toggle-icon">â–¼</span>
        </div>
        <div class="category-content" id="category-${this._sanitizeId(category.name)}">
          ${this._generateTestsList(category.tests || [])}
          ${this._generateIssuesList(category.issues || [])}
          ${this._generateRecommendationsList(category.recommendations || [])}
        </div>
      </div>
`;
    });

    sectionsHTML += '</section>';
    return sectionsHTML;
  }

  /**
   * Generate requirement traceability section
   * Requirements: 1.5, 2.10, 3.10, 4.10, 5.10, 6.10, 7.10, 8.10, 9.10, 10.10
   */
  _generateRequirementTraceability(testResults) {
    const requirements = testResults.requirements || { covered: [], uncovered: [], traceability: {} };
    
    const covered = requirements.covered || [];
    const uncovered = requirements.uncovered || [];
    const coveragePercent = covered.length + uncovered.length > 0
      ? ((covered.length / (covered.length + uncovered.length)) * 100).toFixed(1)
      : 0;
    
    const statusClass = coveragePercent >= 95 ? 'success' 
      : coveragePercent >= 80 ? 'warning' 
      : 'error';

    return `
  <section class="traceability-section">
    <h2>Requirement Traceability</h2>
    <div class="coverage-bar">
      <div class="coverage-label">Coverage: ${coveragePercent}%</div>
      <div class="coverage-progress">
        <div class="coverage-fill ${statusClass}" style="width: ${coveragePercent}%"></div>
      </div>
      <div class="coverage-stats">
        <span class="covered">${covered.length} covered</span>
        <span class="uncovered">${uncovered.length} uncovered</span>
      </div>
    </div>
    
    <div class="requirements-grid">
      <div class="requirements-column">
        <h4>Covered Requirements</h4>
        <ul class="requirements-list covered">
          ${covered.map(req => `<li>${req}</li>`).join('')}
        </ul>
      </div>
      
      ${uncovered.length > 0 ? `
      <div class="requirements-column">
        <h4>Uncovered Requirements</h4>
        <ul class="requirements-list uncovered">
          ${uncovered.map(req => `<li>${req}</li>`).join('')}
        </ul>
      </div>
      ` : ''}
    </div>
    
    <div class="traceability-matrix">
      <h4>Requirement to Test Mapping</h4>
      <table class="traceability-table">
        <thead>
          <tr>
            <th>Requirement</th>
            <th>Tests</th>
            <th>Status</th>
          </tr>
        </thead>
        <tbody>
          ${this._generateTraceabilityRows(requirements.traceability)}
        </tbody>
      </table>
    </div>
  </section>
`;
  }

  /**
   * Generate tests list for a category
   */
  _generateTestsList(tests) {
    if (!tests || tests.length === 0) {
      return '<div class="no-tests">No tests in this category</div>';
    }
    
    return `
    <div class="tests-list">
      <h4>Tests</h4>
      <table class="tests-table">
        <thead>
          <tr>
            <th>Status</th>
            <th>Test Name</th>
            <th>Duration</th>
            <th>Details</th>
          </tr>
        </thead>
        <tbody>
          ${tests.map(test => this._generateTestRow(test)).join('')}
        </tbody>
      </table>
    </div>
`;
  }

  /**
   * Generate a single test row
   */
  _generateTestRow(test) {
    const statusIcon = this._getStatusIcon(test.status);
    const duration = this._formatDuration(test.duration || 0);
    
    const errorDetails = test.errors && test.errors.length > 0 ? `
      <button class="details-btn" onclick="showTestDetails('${test.testId}')">View Errors</button>
      <div class="test-details" id="test-details-${test.testId}" style="display:none;">
        ${test.errors.map(err => `<div class="error-message">${err}</div>`).join('')}
      </div>
    ` : '';

    return `
    <tr class="test-row ${test.status}">
      <td class="status-cell">${statusIcon}</td>
      <td class="test-name">
        <div class="test-title">${test.name || 'Unnamed Test'}</div>
        <div class="test-description">${test.description || ''}</div>
      </td>
      <td class="duration-cell">${duration}</td>
      <td class="details-cell">
        ${errorDetails}
      </td>
    </tr>
`;
  }

  /**
   * Generate issues list
   */
  _generateIssuesList(issues) {
    if (!issues || issues.length === 0) {
      return '';
    }
    
    return `
    <div class="issues-list">
      <h4>Issues Found</h4>
      <ul class="issues">
        ${issues.map(issue => `
          <li class="issue-item ${issue.severity || 'medium'}">
            <span class="issue-severity">${issue.severity || 'medium'}</span>
            <span class="issue-text">${issue.message || issue}</span>
          </li>
        `).join('')}
      </ul>
    </div>
`;
  }

  /**
   * Generate recommendations list
   */
  _generateRecommendationsList(recommendations) {
    if (!recommendations || recommendations.length === 0) {
      return '';
    }
    
    return `
    <div class="recommendations-list">
      <h4>Recommendations</h4>
      <ul class="recommendations">
        ${recommendations.map(rec => `
          <li class="recommendation-item">
            <span class="rec-icon">ðŸ’¡</span>
            <span class="rec-text">${rec.message || rec}</span>
          </li>
        `).join('')}
      </ul>
    </div>
`;
  }

  /**
   * Generate traceability matrix rows
   */
  _generateTraceabilityRows(traceability) {
    if (!traceability || Object.keys(traceability).length === 0) {
      return '<tr><td colspan="3">No traceability data available</td></tr>';
    }
    
    return Object.entries(traceability).map(([req, data]) => {
      const tests = Array.isArray(data) ? data : data.tests || [];
      const status = data.status || (tests.length > 0 ? 'covered' : 'uncovered');
      
      return `
      <tr>
        <td class="req-id">${req}</td>
        <td class="req-tests">${tests.length} test${tests.length !== 1 ? 's' : ''}</td>
        <td class="req-status ${status}">${status}</td>
      </tr>
`;
    }).join('');
  }

  /**
   * Calculate summary statistics
   */
  _calculateSummary(testResults) {
    const categories = testResults.categories || [];
    let totalTests = 0;
    let passed = 0;
    let failed = 0;
    let warnings = 0;
    let skipped = 0;
    
    categories.forEach(category => {
      const tests = category.tests || [];
      tests.forEach(test => {
        totalTests++;
        switch (test.status) {
          case 'passed':
            passed++;
            break;
          case 'failed':
            failed++;
            break;
          case 'warning':
            warnings++;
            break;
          case 'skipped':
            skipped++;
            break;
        }
      });
    });
    
    const successRate = totalTests > 0 ? (passed / totalTests) * 100 : 0;
    
    return {
      totalTests,
      passed,
      failed,
      warnings,
      skipped,
      successRate
    };
  }

  /**
   * Get status icon for display
   */
  _getStatusIcon(status) {
    const icons = {
      passed: 'âœ“',
      failed: 'âœ—',
      warning: 'âš ',
      skipped: 'âŠ˜',
      error: 'âœ—'
    };
    return icons[status] || '?';
  }

  /**
   * Format duration in human-readable format
   */
  _formatDuration(ms) {
    if (ms < 1000) return `${ms}ms`;
    if (ms < 60000) return `${(ms / 1000).toFixed(2)}s`;
    return `${(ms / 60000).toFixed(2)}m`;
  }

  /**
   * Sanitize ID for HTML
   */
  _sanitizeId(str) {
    return str.replace(/[^a-zA-Z0-9-]/g, '-').toLowerCase();
  }

  /**
   * Get CSS styles for the report
   */
  _getReportStyles() {
    return `
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
      line-height: 1.6;
      color: #333;
      background: #f5f5f5;
    }
    
    .report-container {
      max-width: 1400px;
      margin: 0 auto;
      padding: 20px;
    }
    
    .report-header {
      background: white;
      padding: 30px;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      margin-bottom: 20px;
    }
    
    .report-header h1 {
      color: #2c3e50;
      margin-bottom: 15px;
    }
    
    .report-meta {
      display: flex;
      flex-wrap: wrap;
      gap: 20px;
      color: #666;
      font-size: 14px;
    }
    
    .summary-section {
      background: white;
      padding: 30px;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      margin-bottom: 20px;
    }
    
    .summary-section h2 {
      margin-bottom: 20px;
      color: #2c3e50;
    }
    
    .summary-cards {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 15px;
    }
    
    .summary-card {
      background: #f8f9fa;
      padding: 20px;
      border-radius: 8px;
      display: flex;
      align-items: center;
      gap: 15px;
      border-left: 4px solid #6c757d;
    }
    
    .summary-card.success {
      border-left-color: #28a745;
      background: #d4edda;
    }
    
    .summary-card.error {
      border-left-color: #dc3545;
      background: #f8d7da;
    }
    
    .summary-card.warning {
      border-left-color: #ffc107;
      background: #fff3cd;
    }
    
    .card-icon {
      font-size: 32px;
      opacity: 0.8;
    }
    
    .card-value {
      font-size: 28px;
      font-weight: bold;
      color: #2c3e50;
    }
    
    .card-label {
      font-size: 14px;
      color: #666;
    }
    
    .detailed-section {
      background: white;
      padding: 30px;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      margin-bottom: 20px;
    }
    
    .detailed-section h2 {
      margin-bottom: 20px;
      color: #2c3e50;
    }
    
    .category-section {
      margin-bottom: 20px;
      border: 1px solid #dee2e6;
      border-radius: 8px;
      overflow: hidden;
    }
    
    .category-header {
      background: #f8f9fa;
      padding: 15px 20px;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 10px;
      transition: background 0.2s;
    }
    
    .category-header:hover {
      background: #e9ecef;
    }
    
    .category-header h3 {
      flex: 1;
      margin: 0;
      font-size: 18px;
    }
    
    .category-stats {
      color: #666;
      font-size: 14px;
    }
    
    .toggle-icon {
      transition: transform 0.3s;
    }
    
    .category-header.collapsed .toggle-icon {
      transform: rotate(-90deg);
    }
    
    .category-content {
      padding: 20px;
      display: block;
    }
    
    .category-content.hidden {
      display: none;
    }
    
    .status-icon {
      font-size: 20px;
      width: 30px;
      text-align: center;
    }
    
    .status-icon.passed { color: #28a745; }
    .status-icon.failed { color: #dc3545; }
    .status-icon.warning { color: #ffc107; }
    .status-icon.skipped { color: #6c757d; }
    
    .tests-table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 15px;
    }
    
    .tests-table th {
      background: #f8f9fa;
      padding: 12px;
      text-align: left;
      border-bottom: 2px solid #dee2e6;
      font-weight: 600;
    }
    
    .tests-table td {
      padding: 12px;
      border-bottom: 1px solid #dee2e6;
    }
    
    .test-row.passed {
      background: #f8fff9;
    }
    
    .test-row.failed {
      background: #fff8f8;
    }
    
    .test-title {
      font-weight: 600;
      margin-bottom: 4px;
    }
    
    .test-description {
      font-size: 13px;
      color: #666;
    }
    
    .details-btn {
      background: #007bff;
      color: white;
      border: none;
      padding: 6px 12px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 13px;
    }
    
    .details-btn:hover {
      background: #0056b3;
    }
    
    .test-details {
      margin-top: 10px;
      padding: 10px;
      background: #f8f9fa;
      border-radius: 4px;
    }
    
    .error-message {
      color: #dc3545;
      font-family: monospace;
      font-size: 13px;
      margin: 5px 0;
    }
    
    .issues-list, .recommendations-list {
      margin-top: 20px;
    }
    
    .issues-list h4, .recommendations-list h4 {
      margin-bottom: 10px;
      color: #2c3e50;
    }
    
    .issues, .recommendations {
      list-style: none;
    }
    
    .issue-item {
      padding: 10px;
      margin: 8px 0;
      border-left: 4px solid #ffc107;
      background: #fff3cd;
      border-radius: 4px;
    }
    
    .issue-item.critical {
      border-left-color: #dc3545;
      background: #f8d7da;
    }
    
    .issue-item.high {
      border-left-color: #fd7e14;
      background: #ffe5d0;
    }
    
    .issue-severity {
      font-weight: bold;
      text-transform: uppercase;
      font-size: 11px;
      margin-right: 10px;
    }
    
    .recommendation-item {
      padding: 10px;
      margin: 8px 0;
      border-left: 4px solid #17a2b8;
      background: #d1ecf1;
      border-radius: 4px;
      display: flex;
      gap: 10px;
    }
    
    .rec-icon {
      font-size: 18px;
    }
    
    .traceability-section {
      background: white;
      padding: 30px;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      margin-bottom: 20px;
    }
    
    .traceability-section h2 {
      margin-bottom: 20px;
      color: #2c3e50;
    }
    
    .coverage-bar {
      margin-bottom: 30px;
    }
    
    .coverage-label {
      font-size: 18px;
      font-weight: bold;
      margin-bottom: 10px;
    }
    
    .coverage-progress {
      height: 30px;
      background: #e9ecef;
      border-radius: 15px;
      overflow: hidden;
      margin-bottom: 10px;
    }
    
    .coverage-fill {
      height: 100%;
      transition: width 0.5s;
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-weight: bold;
    }
    
    .coverage-fill.success {
      background: linear-gradient(90deg, #28a745, #20c997);
    }
    
    .coverage-fill.warning {
      background: linear-gradient(90deg, #ffc107, #fd7e14);
    }
    
    .coverage-fill.error {
      background: linear-gradient(90deg, #dc3545, #c82333);
    }
    
    .coverage-stats {
      display: flex;
      gap: 20px;
      font-size: 14px;
    }
    
    .covered {
      color: #28a745;
      font-weight: bold;
    }
    
    .uncovered {
      color: #dc3545;
      font-weight: bold;
    }
    
    .requirements-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
      gap: 20px;
      margin-bottom: 30px;
    }
    
    .requirements-column h4 {
      margin-bottom: 10px;
      color: #2c3e50;
    }
    
    .requirements-list {
      list-style: none;
      padding: 0;
    }
    
    .requirements-list li {
      padding: 8px 12px;
      margin: 5px 0;
      background: #f8f9fa;
      border-radius: 4px;
      border-left: 3px solid #28a745;
    }
    
    .requirements-list.uncovered li {
      border-left-color: #dc3545;
      background: #fff5f5;
    }
    
    .traceability-table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 15px;
    }
    
    .traceability-table th {
      background: #f8f9fa;
      padding: 12px;
      text-align: left;
      border-bottom: 2px solid #dee2e6;
      font-weight: 600;
    }
    
    .traceability-table td {
      padding: 12px;
      border-bottom: 1px solid #dee2e6;
    }
    
    .req-status.covered {
      color: #28a745;
      font-weight: bold;
    }
    
    .req-status.uncovered {
      color: #dc3545;
      font-weight: bold;
    }
    
    .report-footer {
      text-align: center;
      padding: 20px;
      color: #666;
      font-size: 14px;
    }
    
    .no-tests {
      padding: 20px;
      text-align: center;
      color: #666;
      font-style: italic;
    }
    
    @media print {
      body {
        background: white;
      }
      
      .report-container {
        max-width: 100%;
      }
      
      .category-content {
        display: block !important;
      }
      
      .details-btn {
        display: none;
      }
    }
`;
  }

  /**
   * Get JavaScript for report interactivity
   */
  _getReportScripts() {
    return `
    function toggleCategory(categoryId) {
      const content = document.getElementById('category-' + categoryId);
      const header = content.previousElementSibling;
      
      if (content.classList.contains('hidden')) {
        content.classList.remove('hidden');
        header.classList.remove('collapsed');
      } else {
        content.classList.add('hidden');
        header.classList.add('collapsed');
      }
    }
    
    function showTestDetails(testId) {
      const details = document.getElementById('test-details-' + testId);
      if (details.style.display === 'none') {
        details.style.display = 'block';
      } else {
        details.style.display = 'none';
      }
    }
    
    // Initialize all categories as expanded
    document.addEventListener('DOMContentLoaded', function() {
      console.log('Test report loaded successfully');
    });
`;
  }

  /**
   * Generate JSON report for machine-readable results
   * Requirements: 1.5, 2.10, 3.10, 4.10, 5.10, 6.10, 7.10, 8.10, 9.10, 10.10
   */
  generateJSONReport(testResults) {
    const timestamp = new Date().toISOString();
    const summary = this._calculateSummary(testResults);
    
    const report = {
      metadata: {
        timestamp,
        duration: testResults.metadata?.duration || 0,
        environment: testResults.metadata?.environment || 'Unknown',
        version: testResults.metadata?.version || 'N/A',
        generatedBy: 'Comprehensive Test Suite'
      },
      summary: {
        totalTests: summary.totalTests,
        passed: summary.passed,
        failed: summary.failed,
        warnings: summary.warnings,
        skipped: summary.skipped,
        successRate: summary.successRate
      },
      categories: (testResults.categories || []).map(category => ({
        name: category.name,
        status: category.status,
        tests: (category.tests || []).map(test => ({
          testId: test.testId,
          name: test.name,
          description: test.description,
          status: test.status,
          duration: test.duration,
          requirements: test.requirements || [],
          errors: test.errors || [],
          warnings: test.warnings || [],
          assertions: test.assertions || []
        })),
        issues: category.issues || [],
        recommendations: category.recommendations || []
      })),
      requirements: {
        covered: testResults.requirements?.covered || [],
        uncovered: testResults.requirements?.uncovered || [],
        traceability: testResults.requirements?.traceability || {},
        coveragePercent: this._calculateRequirementCoverage(testResults.requirements)
      }
    };
    
    return JSON.stringify(report, null, 2);
  }

  /**
   * Generate CSV report for spreadsheet analysis
   * Requirements: 1.5, 2.10, 3.10, 4.10, 5.10, 6.10, 7.10, 8.10, 9.10, 10.10
   */
  generateCSVReport(testResults) {
    const rows = [];
    
    // Header row
    rows.push([
      'Category',
      'Test ID',
      'Test Name',
      'Status',
      'Duration (ms)',
      'Requirements',
      'Errors',
      'Warnings'
    ]);
    
    // Data rows
    const categories = testResults.categories || [];
    categories.forEach(category => {
      const tests = category.tests || [];
      
      if (tests.length === 0) {
        // Add category row even if no tests
        rows.push([
          category.name,
          '',
          'No tests',
          category.status || 'unknown',
          '',
          '',
          '',
          ''
        ]);
      } else {
        tests.forEach(test => {
          rows.push([
            category.name,
            test.testId || '',
            test.name || 'Unnamed Test',
            test.status || 'unknown',
            test.duration || 0,
            (test.requirements || []).join('; '),
            (test.errors || []).join('; '),
            (test.warnings || []).join('; ')
          ]);
        });
      }
    });
    
    // Convert to CSV format
    return rows.map(row => 
      row.map(cell => this._escapeCSVCell(cell)).join(',')
    ).join('\n');
  }

  /**
   * Save reports to files with history management
   * Requirements: 1.5, 2.10, 3.10, 4.10, 5.10, 6.10, 7.10, 8.10, 9.10, 10.10
   */
  async saveReports(testResults, formats = ['html', 'json', 'csv']) {
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    const savedFiles = [];
    
    try {
      // Generate reports in requested formats
      const reports = {};
      
      if (formats.includes('html')) {
        reports.html = {
          content: this.generateHTMLReport(testResults),
          filename: `test-report-${timestamp}.html`,
          path: `${this.config.outputDir}/test-report-${timestamp}.html`
        };
      }
      
      if (formats.includes('json')) {
        reports.json = {
          content: this.generateJSONReport(testResults),
          filename: `test-report-${timestamp}.json`,
          path: `${this.config.outputDir}/test-report-${timestamp}.json`
        };
      }
      
      if (formats.includes('csv')) {
        reports.csv = {
          content: this.generateCSVReport(testResults),
          filename: `test-report-${timestamp}.csv`,
          path: `${this.config.outputDir}/test-report-${timestamp}.csv`
        };
      }
      
      // Save each report
      for (const [format, report] of Object.entries(reports)) {
        try {
          // In browser environment, trigger download
          if (typeof window !== 'undefined' && typeof document !== 'undefined') {
            this._downloadFile(report.content, report.filename, this._getMimeType(format));
            savedFiles.push({ format, filename: report.filename, status: 'downloaded' });
          } 
          // In Node.js environment, write to file system
          else if (typeof require !== 'undefined') {
            const fs = require('fs');
            const path = require('path');
            
            // Create output directory if it doesn't exist
            const dir = path.dirname(report.path);
            if (!fs.existsSync(dir)) {
              fs.mkdirSync(dir, { recursive: true });
            }
            
            // Write file
            fs.writeFileSync(report.path, report.content, 'utf8');
            savedFiles.push({ format, filename: report.filename, path: report.path, status: 'saved' });
          }
        } catch (error) {
          savedFiles.push({ format, filename: report.filename, status: 'error', error: error.message });
        }
      }
      
      // Update report history
      this._updateReportHistory({
        timestamp: new Date().toISOString(),
        files: savedFiles,
        summary: this._calculateSummary(testResults)
      });
      
      // Clean up old reports if history limit exceeded
      this._cleanupOldReports();
      
      return {
        success: true,
        files: savedFiles,
        timestamp
      };
      
    } catch (error) {
      return {
        success: false,
        error: error.message,
        files: savedFiles
      };
    }
  }

  /**
   * Get report history
   */
  getReportHistory() {
    return this.reportHistory;
  }

  /**
   * Clear report history
   */
  clearReportHistory() {
    this.reportHistory = [];
  }

  /**
   * Calculate requirement coverage percentage
   */
  _calculateRequirementCoverage(requirements) {
    if (!requirements) return 0;
    
    const covered = requirements.covered || [];
    const uncovered = requirements.uncovered || [];
    const total = covered.length + uncovered.length;
    
    return total > 0 ? ((covered.length / total) * 100).toFixed(1) : 0;
  }

  /**
   * Escape CSV cell content
   */
  _escapeCSVCell(cell) {
    const str = String(cell);
    
    // If cell contains comma, quote, or newline, wrap in quotes and escape quotes
    if (str.includes(',') || str.includes('"') || str.includes('\n')) {
      return `"${str.replace(/"/g, '""')}"`;
    }
    
    return str;
  }

  /**
   * Get MIME type for file format
   */
  _getMimeType(format) {
    const mimeTypes = {
      html: 'text/html',
      json: 'application/json',
      csv: 'text/csv'
    };
    return mimeTypes[format] || 'text/plain';
  }

  /**
   * Download file in browser
   */
  _downloadFile(content, filename, mimeType) {
    const blob = new Blob([content], { type: mimeType });
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = url;
    link.download = filename;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);
  }

  /**
   * Update report history
   */
  _updateReportHistory(entry) {
    this.reportHistory.unshift(entry);
    
    // Keep only the most recent entries
    if (this.reportHistory.length > this.config.historyLimit) {
      this.reportHistory = this.reportHistory.slice(0, this.config.historyLimit);
    }
  }

  /**
   * Clean up old report files
   */
  _cleanupOldReports() {
    // Only cleanup in Node.js environment
    if (typeof require === 'undefined') return;
    
    try {
      const fs = require('fs');
      const path = require('path');
      
      if (!fs.existsSync(this.config.outputDir)) return;
      
      // Get all report files
      const files = fs.readdirSync(this.config.outputDir)
        .filter(file => file.startsWith('test-report-'))
        .map(file => ({
          name: file,
          path: path.join(this.config.outputDir, file),
          time: fs.statSync(path.join(this.config.outputDir, file)).mtime.getTime()
        }))
        .sort((a, b) => b.time - a.time);
      
      // Keep only recent files (3x history limit to account for multiple formats)
      const keepCount = this.config.historyLimit * 3;
      const filesToDelete = files.slice(keepCount);
      
      filesToDelete.forEach(file => {
        try {
          fs.unlinkSync(file.path);
        } catch (error) {
          console.warn(`Failed to delete old report: ${file.name}`, error);
        }
      });
      
    } catch (error) {
      console.warn('Failed to cleanup old reports:', error);
    }
  }
}

// Export for use in other modules
if (typeof module !== 'undefined' && module.exports) {
  module.exports = ReportGenerationModule;
}
